" ============================================================================
" Vim-plug initialization
" Avoid modify this section, unless you are very sure of what you are doing

let vim_plug_just_installed = 0
let vim_plug_path = expand('~/.vim/autoload/plug.vim')
if !filereadable(vim_plug_path)
    silent !mkdir -p ~/.vim/autoload
    silent !curl -fLo ~/.vim/autoload/plug.vim --create-dirs https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
    :execute 'source '.fnameescape(vim_plug_path)
    let vim_plug_just_installed = 1
endif

" ============================================================================
" Active plugins
call plug#begin('~/.vim/plug')

if filereadable(expand('~/.vimrc.plugins'))
    source ~/.vimrc.plugins
endif

call plug#end()

if vim_plug_just_installed
    echo "Installing Bundles"
    :PlugInstall
endif

" ============================================================================
" Vim settings

" Encode ----------------------------------------
set fileencodings=utf-8,gb2312,gbk,cp936,latin-1
set fileencoding=utf-8
set termencoding=utf-8
set encoding=utf-8
set fileformat=unix

" UI --------------------------------------------
syntax on  " syntax highlight on
set t_Co=256
set background=dark
colorscheme solarized
" set cursorline  " highlight cursor line
" highlight CursorLine cterm=Bold ctermbg=Black ctermfg=NONE guibg=Black guifg=NONE
set signcolumn=yes

" Basic Config ----------------------------------
set nocompatible  " no vi-compatible
filetype plugin on  " allow plugins by file type (required for plugins!)
filetype indent on

set ls=2  " always show status bar
set number  " show line numbers
set showcmd  " show cmd in the bottom
set showmatch  " highlight matched parenthese automatically
set scrolloff=3  " when scrolling, keep cursor * lines away from screen border horizontally
set sidescrolloff=3  " keep cursor * lines away from screen border vertically
set nobackup  " Don't create backup file
set noerrorbells " No bells when error

set history=1024  " history buffer size
set autoread  " Prompt if the file being edited is modified externally
set autowrite  " auto save

set incsearch  " incremental search
set hlsearch  " highlighted search results
set ignorecase
set smartcase

" Editor -------------------------------------
set expandtab  " replace tab with spaces
set tabstop=4
set softtabstop=4
set shiftwidth=4

set autoindent
set smartindent

set backspace=indent,eol,start  " use backspace to delete
set whichwrap=h,l  " use h/l to move to previous/next line

set complete=.,w,b,u,t,i,d
set completeopt=longest,menuone
set pumheight=10  " The number of items to show

set wildmenu
set wildmode=longest:list,full

set tags=./tags;
" ============================================
" Auto Command

" 打开文件光标自动跳转到上次关闭时的位置
autocmd BufReadPost *
    \ if line("'\"") > 0 && line("'\"") <= line("$") |
    \     exe "normal g'\"" |
    \ endif ""

" ===========================================
" Key mappings

let mapleader=' '  " Leader

" enter command mode with semicolon
nnoremap ; :
vnoremap ; :

" Switch in windows
nnoremap <C-h> <C-w>h
nnoremap <C-j> <C-w>j
nnoremap <C-k> <C-w>k
nnoremap <C-l> <C-w>l
inoremap <C-h> <Esc><C-w>h
inoremap <C-j> <Esc><C-w>j
inoremap <C-k> <Esc><C-w>k
inoremap <C-l> <Esc><C-w>l

" Resize Window
nnoremap <Leader>+ :resize +1<cr>
nnoremap <Leader>_ :resize -1<cr>
nnoremap + :vertical resize +1<cr>
nnoremap _ :vertical resize -1<cr> 

" tab navigation mappings
map tn :tabn<CR>
map tp :tabp<CR>
map tm :tabm 
map tt :tabnew 
map ts :tab split<CR>

" shell命令调用函数
function! RunShell(Msg, Shell)
    echo a:Msg . '...'
    call system(a:Shell)
    echon 'done'
endfunction

" Save generate files to the directory

" vimgrep查找字符串
nmap <F6> :vimgrep /<C-R>=expand("<cword>")<cr>/ **/*.c **/*.h **/*.py<cr><C-o>:cw<cr>
" 生成GTAGS数据库文件快捷键F8
" nmap <F8> :call RunShell("Generate GTAGS.*", 'find . -name "*.[chsS]" -o -name "*.cpp" -o -name "*.cc" -o --name "*.py" -o -name "*.C", -o -name "*.cxx"> gtags.files && gtags')<cr>
" " 生成tags文件快捷键F9
" nmap <F9> :call RunShell("Generate tags", "ctags -R --c-kinds=+lpxzL --c++-kinds=+lpxzLANU --fields=+niazS --extras=+q --o    utput-format=e-ctags")<cr>
" " 生成cscope数据库文件快捷键F10
" nmap <F10> :call RunShell("Generate cscope.*", 'find `pwd` -name "*.[chsS]" -o -name "*.cpp" -o -name "*.cc" -o -name "*.py" -o -name "*.C", -o -name "*.cxx"> cscope.files && cscope -bkq')<cr>
" " 更新cscope或者GTAGS数据库快捷键F12
" nmap <F12> :call UpdateDb()<cr>

" ============================================================================
" Plugins settings and mappings

" LeaderF
" -----------------------------------------------------------------------------
let g:Lf_ShortcutF = '<c-p>'
let g:Lf_ShortcutB = '<m-n>'
noremap <c-n> :LeaderfMru<cr>
noremap <m-p> :LeaderfFunction!<cr>
noremap <m-n> :LeaderfBuffer<cr>
noremap <m-m> :LeaderfTag<cr>
let g:Lf_StlSeparator = { 'left': '', 'right': '', 'font': '' }

let g:Lf_RootMarkers = ['.project', '.root', '.svn', '.git']
let g:Lf_WorkingDirectoryMode = 'Ac'
let g:Lf_WindowHeight = 0.30
let g:Lf_CacheDirectory = expand('~/.vim/cache')
let g:Lf_ShowRelativePath = 0
let g:Lf_HideHelp = 1
let g:Lf_StlColorscheme = 'powerline'
let g:Lf_PreviewResult = {'Function':0, 'BufTag':0}

" echodoc.vim 
" -----------------------------------------------------------------------------
set noshowmode
let g:echodoc#enable_at_startup = 1

" taglist.vim
" -----------------------------------------------------------------------------
" 设置打开关闭快捷键F2 
nmap  <F3> :TlistToggle<cr>
" 自动更新tags列表
let g:Tlist_Auto_Update=1
" 始终解析文件中的tag,不管taglist窗口有没有打开
let g:Tlist_Process_File_Always=1
" 当taglist窗口是最后一个窗口时退出vim
let g:Tlist_Exit_OnlyWindow=1
" 只显示一个文件的tags
let g:Tlist_Show_One_File=1
" 窗口宽度
let g:Tlist_WinWidth=30
" 只显示当前文件的tags
let g:Tlist_Enable_Fold_Column=0
" 高亮显示当前tag
let g:Tlist_Auto_Highlight_Tag=1
" 设置窗口显示在右侧
let g:Tlist_Use_Right_Window=1
" 打开时光标定位于taglist窗口
let g:Tlist_GainFocus_On_ToggleOpen=1

" NERDTree.vim
" -----------------------------------------------------------------------------
" 设置打开关闭快捷键F3
nmap  <F2> :NERDTreeToggle<cr>
" 窗口美化
let NERDChristmasTree=1
" 自动调整光标到窗口中心
let NERDTreeAutoCenter=1
" 指定鼠标模式(1.双击打开;2.单目录双文件;3.单击打开)
let NERDTreeMouseMode=2
" 默认显示文件
let NERDTreeShowFiles=1
" 默认显示隐藏文件
let NERDTreeShowHidden=1
" 窗口位置（'left' or 'right'）
let g:NERDTreeWinPos="left"
" 窗口宽度
let g:NERDTreeWinSize=30
" 显示行号
let g:NERDTreeShowLineNumbers=1
" 打开文件后关闭NERDTree窗口
" let g:NERDTreeQuitOnOpen=1
" 高亮显示当前行目录或文件
let NERDTreeHightCursorline=1
" open nerdtree with the current file selected
nmap ,t :NERDTreeFind<CR>
" don;t show these file types
let NERDTreeIgnore = ['\.pyc$', '\.pyo$', '\.o$']

" cscope配置
" -----------------------------------------------------------------------------
" cscope数据库更新完毕回调函数
function! UpcsCallback(...)
    execute "cs reset"
endfunction

" 更新cscope数据库函数
function! UpdateCsdb(path)
    if (a:path != '')
        execute "cd " . a:path
    endif
    call job_start("cscope -bkq", {'exit_cb': 'UpcsCallback'})
    if (a:path != '')
        execute "cd -"
    endif
endfunction

" 更新GTAGS数据库函数
function! UpdateGtags(f)
    let l:dir = fnamemodify(a:f, ':p:h')
    execute "cd " . l:dir
    call job_start("global -u")
    execute "cd -"
endfunction

" 更新cscope或者GTAGS数据库
function! UpdateDb()
    if g:csflag == 0
        call UpdateCsdb(g:cspath)
    elseif g:csflag == 1
        call UpdateGtags(expand('<afile>'))
    else
    endif
endfunction

if executable('cscope')
    " 获取GTAGS目录
    let s:gtfile = system('global -pq')
    " 向上递归寻找cscope.files
    let g:csfile = findfile("cscope.out", ".;")

    " 如果存在cscope.out则获取目录
    if filereadable(g:csfile)
        " 设置cscope模式标志
        let g:csflag = 0
        " 获取cscope.out目录
        let s:pathlen = strridx(g:csfile, "cscope.out")
        let g:cspath = strpart(g:csfile, 0, s:pathlen)
    " 如果存在GTAGS则获取目录
    elseif s:gtfile != ""
        " 设置cscope模式标志
        let g:csflag = 1
        " 获取GTAGS目录
        let g:gtpath = strpart(s:gtfile, 0, strlen(s:gtfile) - 1)
    " 否则使用gutentags_plus
    else
        " 设置cscope模式标志
        let g:csflag = 2
    endif

    " cscope程序位置
    if !exists("g:cspath") && executable('gtags-cscope')
        " 设置cscope映射的程序
        set csprg=/usr/local/bin/gtags-cscope
        if g:csflag == 1
            " 加载GTAGS
            execute 'silent cs add ' . g:gtpath . '/GTAGS'
            " 保存文件后自动更新GTAGS
            autocmd BufWritePost * call UpdateGtags(expand('<afile>'))
        endif
    elseif g:csfile != ""
        " 设置cscope映射的程序
        set csprg=/usr/local/bin/cscope
        " 自动命令查找结果不使用quickfix窗口
        " autocmd BufReadPost * set cscopequickfix=""
        " 保存文件后自动更新GTAGS
        autocmd BufWritePost * call UpdateCsdb(g:cspath)
        " 加载cscope.out
        set nocsverb
        execute 'cs add ' . g:csfile
    endif

    " 显示添加数据库结果
    set csverb
    " 使用cstag命令代替tag命令
    set cst
    " 优先搜索cscope.out,失败再搜索tags
    set csto=0
    " 显示文件路径全名
    set cspc=0
endif

" cscope当前窗口直接跳转快捷键
nnoremap <Leader>fs :cs find s <C-R>=expand("<cword>")<cr><cr>
nnoremap <Leader>fg :cs find g <C-R>=expand("<cword>")<cr><cr>
nnoremap <Leader>fd :cs find d <C-R>=expand("<cword>")<cr><cr>
nnoremap <Leader>fc :cs find c <C-R>=expand("<cword>")<cr><cr>
nnoremap <Leader>ft :cs find t <C-R>=expand("<cword>")<cr><cr>
nnoremap <Leader>fe :cs find e <C-R>=expand("<cword>")<cr><cr>
nnoremap <Leader>ff :cs find f <C-R>=expand("<cfile>")<cr><cr>
nnoremap <Leader>fi :cs find i <C-R>=expand("<cfile>")<cr><cr>
nnoremap <Leader>fa :cs find a <C-R>=expand("<cword>")<cr><cr>

" cscope跳转同时新建水平分割窗口快捷键
nnoremap <Leader>ss :scs find s <C-R>=expand("<cword>")<cr><cr>
nnoremap <Leader>sg :scs find g <C-R>=expand("<cword>")<cr><cr>
nnoremap <Leader>sd :scs find d <C-R>=expand("<cword>")<cr><cr>
nnoremap <Leader>sc :scs find c <C-R>=expand("<cword>")<cr><cr>
nnoremap <Leader>st :scs find t <C-R>=expand("<cword>")<cr><cr>
nnoremap <Leader>se :scs find e <C-R>=expand("<cword>")<cr><cr>
nnoremap <Leader>sf :scs find f <C-R>=expand("<cfile>")<cr><cr>
nnoremap <Leader>si :scs find i <C-R>=expand("<cfile>")<cr><cr>
nnoremap <Leader>sa :scs find a <C-R>=expand("<cword>")<cr><cr>

" cscope跳转同时新建垂直分割窗口快捷键
nnoremap <Leader>vs :vert scs find s <C-R>=expand("<cword>")<cr><cr>
nnoremap <Leader>vg :vert scs find g <C-R>=expand("<cword>")<cr><cr>
nnoremap <Leader>vd :vert scs find d <C-R>=expand("<cword>")<cr><cr>
nnoremap <Leader>vc :vert scs find c <C-R>=expand("<cword>")<cr><cr>
nnoremap <Leader>vt :vert scs find t <C-R>=expand("<cword>")<cr><cr>
nnoremap <Leader>ve :vert scs find e <C-R>=expand("<cword>")<cr><cr>
nnoremap <Leader>vf :vert scs find f <C-R>=expand("<cfile>")<cr><cr>
nnoremap <Leader>vi :vert scs find i <C-R>=expand("<cfile>")<cr><cr>
nnoremap <Leader>va :vert scs find a <C-R>=expand("<cword>")<cr><cr>

" gutentags.vim && gutentags_plus.vim
" -----------------------------------------------------------------------------
let $GTAGSLABEL = 'native-pygments'
let $GTAGSCONF = '/usr/local/share/gtags/gtags.conf'
" 搜索工程目录的标志，碰到这些文件/目录名就停止向上一级目录递归 "
let g:gutentags_project_root = ['.root', '.svn', '.git', '.project']
" 所生成的数据文件的名称 "
let g:gutentags_ctags_tagfile = '.tags'
" tags模式设置
let g:gutentags_modules = []
if executable('ctags')
    let g:gutentags_modules += ['ctags']
endif
if executable('gtags-cscope') && executable('gtags')
    let g:gutentags_modules += ['gtags_cscope']
endif
" 将自动生成的 tags 文件全部放入 ~/.cache/tags 目录中，避免污染工程目录 "
let s:vim_tags = expand('~/.cache/tags')
let g:gutentags_cache_dir = s:vim_tags
" 检测 ~/.cache/tags 不存在就新建 "
if !isdirectory(s:vim_tags)
   silent! call mkdir(s:vim_tags, 'p')
endif
" 配置ctags的参数 "
let g:gutentags_ctags_extra_args = ['--fields=+niazS', '--extras=+q']
let g:gutentags_ctags_extra_args += ['--c++-kinds=+lpxzLANU']
let g:gutentags_ctags_extra_args += ['--c-kinds=+lpxzL']
" 如果使用universal ctags需要增加下面一行
let g:gutentags_ctags_extra_args += ['--output-format=e-ctags']
" 禁用 gutentags 自动加载 gtags 数据库的行为
" 避免多个项目数据库相互干扰
" 使用plus插件解决问题
let g:gutentags_auto_add_gtags_cscope = 0

" vim-preview.vim
" p预览 大P关闭
autocmd FileType qf nnoremap <silent><buffer> p :PreviewQuickfix<cr>
autocmd FileType qf nnoremap <silent><buffer> P :PreviewClose<cr>
noremap <Leader>u :PreviewScroll -1<cr> " 往上滚动预览窗口
noremap <Leader>d :PreviewScroll +1<cr> " 往下滚动预览窗口

" Window Chooser ------------------------------

" mapping
nmap  -  <Plug>(choosewin)
" show big letters
let g:choosewin_overlay_enable = -1

" YouCompleteMe.vim
" -----------------------------------------------------------------------------
" 补全配置脚本
let g:ycm_global_ycm_extra_conf='~/.vim/.ycm_extra_conf.py'

" 弹出列表时选择第1项的快捷键(默认为<TAB>和<Down>)
let g:ycm_key_list_select_completion = ['<C-n>', '<Down>']
" 弹出列表时选择前1项的快捷键(默认为<S-TAB>和<UP>)
let g:ycm_key_list_previous_completion = ['<C-p>', '<Up>']
" 主动补全, 默认为<C-Space>
let g:ycm_key_invoke_completion = '<C-x>'
" 停止显示补全列表(防止列表影响视野),可以按<C-x>重新弹出
let g:ycm_key_list_stop_completion = ['<C-y>']

" 停止提示是否载入本地ycm_extra_conf文件
let g:ycm_confirm_extra_conf = 0

let g:ycm_seed_identifiers_with_syntax = 1
" 开启YCM 基于标签引擎
let g:ycm_collect_identifiers_from_tags_files = 1
" 从第2个键入字符就开始罗列匹配项
let g:ycm_min_num_of_chars_for_completion = 2
" 开启输入注释时补全
let g:ycm_complete_in_comments = 1
" 开启输入字符串时补全
let g:ycm_complete_in_strings = 1
" 开启注释和字符串中收集补全
let g:ycm_collect_identifiers_from_comments_and_strings = 1
" 关闭函数预览
let g:ycm_add_preview_to_completeopt = 0
" 关闭代码诊断
let g:ycm_show_diagnostics_ui = 0
" 设置标识符补全最小字符数
let g:ycm_min_num_identifier_candidate_chars = 2
" 设置以下语言自动弹出语义补全(默认需要输入'.->::'或者按主动补全组合键)
let g:ycm_semantic_triggers =  {
            \ 'c,cpp,python,java,go,erlang,perl': ['re!\w{2}'],
            \ 'cs,lua,javascript': ['re!\w{2}'],
            \ }
" 白名单(以外的文件类型不分析补全)
let g:ycm_filetype_whitelist = {
            \ "s":1,
            \ "S":1,
            \ "c":1,
            \ "C":1,
            \ "cc":1,
            \ "cxx":1,
            \ "cpp":1,
            \ "py":1,
            \ "go":1,
            \ "java":1,
            \ "objc":1,
            \ "sh":1,
            \ "zsh":1,
            \ "zimbu":1,
            \ "txt":1,
            \ "conf":1,
            \ "vimrc":1,
            \ "bashrc":1,
            \ }

" ALE.vim
" -----------------------------------------------------------------------------
"普通模式下警告跳转快捷键
nmap <silent> <Leader>p <Plug>(ale_previous_wrap)
nmap <silent> <Leader>n <Plug>(ale_next_wrap)
"<Leader>x触发/关闭语法检查
nmap <Leader>x :ALEToggle<CR>
"<Leader>y查看错误或警告的详细信息
nmap <Leader>y :ALEDetail<CR>
"始终开启标志列
" let g:ale_sign_column_always = 1
" 错误警告消息格式
let g:ale_echo_msg_error_str = 'E'
let g:ale_echo_msg_warning_str = 'W'
let g:ale_echo_msg_format = '[%linter%] %s [%severity%]'
" 文件打开时不进行检查
let g:ale_lint_on_enter = 0
" 文件修改时不进行检查
let g:ale_lint_on_text_changed = 'never'
" 文件保存时进行检查(默认)
"let g:ale_lint_on_save = 1
" 指定对应语言的检查工具
let g:ale_linters = {
            \   'c++': ['clang'],
            \   'c': ['clang'],
            \   'python': ['pylint'],
            \   'go': ['gofmt', 'golint'],
            \}
" 关闭补全功能
let g:ale_completion_enabled = 0
" 使能airline状态栏扩展
let g:airline#extensions#ale#enabled = 1
" 禁用高亮显示
"let g:ale_set_highlights = 0
" 自定义error和warning标志
"let g:ale_sign_error = '✗'
"let g:ale_sign_warning = '⚡'

" airline.vim
" -----------------------------------------------------------------------------
" 设置主题
let g:airline_theme='molokai' "'bubblegum'
" 这个是安装字体后必须设置此项"
let g:airline_powerline_fonts = 1
" 开启标签栏
let g:airline#extensions#tabline#enabled = 1
" 显示缓冲区编号
let g:airline#extensions#tabline#buffer_nr_show = 1
" tabline中当前buffer两端的分隔字符
"let g:airline#extensions#tabline#left_sep = ' '
" tabline中未激活buffer两端的分隔字符
"let g:airline#extensions#tabline#left_alt_sep = '|'
" 缓冲区切换快捷键
nnoremap <Leader>. :bn<cr>
nnoremap <Leader>, :bp<cr>
nnoremap <Tab> :bn<cr>
" 关闭状态显示空白符号计数"
let g:airline#extensions#whitespace#enabled = 0
" 状态栏显示设置
if !exists('g:airline_symbols')
    let g:airline_symbols = {}
endif
" powerline symbols
let g:airline_left_sep = ''
let g:airline_left_alt_sep = ''
let g:airline_right_sep = ''
let g:airline_right_alt_sep = ''
let g:airline_symbols.branch = ''
let g:airline_symbols.readonly = ''
let g:airline_symbols.linenr = '☰'
let g:airline_symbols.maxlinenr = ''

